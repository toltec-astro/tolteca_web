import sys
sys.path.append("/Users/wilson/GitHub/toltec-data-product-utilities/toltec_dp_utils/")
from ToltecSignalFits import ToltecSignalFits

from dash_component_template import ComponentTemplate, NullComponent
from dash.dependencies import Input, Output, State
from dash.exceptions import PreventUpdate
from plotly.subplots import make_subplots
import dash_bootstrap_components as dbc
from ..common import LabeledInput
from tollan.utils.log import logger
import dash_core_components as dcc
import plotly.graph_objs as go
import plotly.express as px
from dash import html
from glob import glob
import numpy as np
import os


class ToltecSignalFitsViewer(ComponentTemplate):
    class Meta:
        component_cls = dbc.Container

    def __init__(
            self,
            title_text="Toltec Signal Fits Viewer",
            subtitle_text="(test version)",
            **kwargs,
    ):
        kwargs.setdefault("fluid", True)
        super().__init__(**kwargs)
        self._title_text = title_text
        self._subtitle_text = subtitle_text
        self.fluid = True

    def setup_layout(self, app):
        container = self
        header, body = container.grid(2, 1)

        # Header
        title_container = header.child(
            html.Div, className="d-flex align-items-baseline"
        )
        title_container.child(html.H2(self._title_text, className="my-2"))
        if self._subtitle_text is not None:
            title_container.child(
                html.P(self._subtitle_text, className="text-secondary mx-2")
            )

        # Hard code the input path for testing.
        dPath = '/Users/wilson/Desktop/tmp/macs0717/pointing/102384/'
        g = glob('{}redu*/'.format(dPath))
        pathOptions = [{'label': gg, 'value': gg} for gg in g]

        # pull down to select signal fits path
        controls_panel, views_panel, bigBox = body.grid(3, 1)
        controlBox = controls_panel.child(dbc.Row).child(dbc.Col, width=5)
        settingsRow = controlBox.child(dbc.Row)
        fitsPath_select = settingsRow.child(dbc.Col).child(
            dcc.Dropdown,
            options=pathOptions,
            placeholder="Select Path",
            value='',
            searchable=False,
            style=dict(
                width='100%',
                verticalAlign="middle"
            ))

        # Put in a break
        bigBox.child(dbc.Row).child(html.Br)

        # The maps
        topImageRow = bigBox.child(dbc.Row)
        topImageBox = topImageRow.child(dbc.Col, width=12)
        topImageControls = topImageBox.child(dbc.Row)
        signalControls = topImageControls.child(dbc.Col, width=4).child(dbc.Row)
        signalControlsVmin = signalControls.child(dbc.Col, width=6).child(
            LabeledInput(
                label_text="Vmin", className="w-auto", size="sm",
                input_props={"type": "number", "debounce": True, "value": None,},))
        signalControlsVmax = signalControls.child(dbc.Col, width=6).child(
            LabeledInput(
                label_text="Vmax", className="w-auto", size="sm",
                input_props={"type": "number", "debounce": True, "value": None,},))
        weightControls = topImageControls.child(dbc.Col, width=4).child(dbc.Row)
        weightControlsVmin = weightControls.child(dbc.Col, width=6).child(
            LabeledInput(
                label_text="Vmin", className="w-auto", size="sm",
                input_props={"type": "number", "debounce": True, "value": None,},))
        weightControlsVmax = weightControls.child(dbc.Col, width=6).child(
            LabeledInput(
                label_text="Vmax", className="w-auto", size="sm",
                input_props={"type": "number", "debounce": True, "value": None,},))
        kernelControls = topImageControls.child(dbc.Col, width=4).child(dbc.Row)
        kernelControlsVmin = kernelControls.child(dbc.Col, width=6).child(
            LabeledInput(
                label_text="Vmin", className="w-auto", size="sm",
                input_props={"type": "number", "debounce": True, "value": None,},))
        kernelControlsVmax = kernelControls.child(dbc.Col, width=6).child(
            LabeledInput(
                label_text="Vmax", className="w-auto", size="sm",
                input_props={"type": "number", "debounce": True, "value": None,},))
        topImage = topImageBox.child(dbc.Row).child(dcc.Graph)
        botImageControls = topImageBox.child(dbc.Row)
        coverControls = botImageControls.child(dbc.Col, width=4).child(dbc.Row)
        coverControlsVmin = coverControls.child(dbc.Col, width=6).child(
            LabeledInput(
                label_text="Vmin", className="w-auto", size="sm",
                input_props={"type": "number", "debounce": True, "value": None,},))
        coverControlsVmax = coverControls.child(dbc.Col, width=6).child(
            LabeledInput(
                label_text="Vmax", className="w-auto", size="sm",
                input_props={"type": "number", "debounce": True, "value": None,},))
        boolControls = botImageControls.child(dbc.Col, width=4).child(dbc.Row)
        boolControlsVmin = boolControls.child(dbc.Col, width=6).child(
            LabeledInput(
                label_text="Vmin", className="w-auto", size="sm",
                input_props={"type": "number", "debounce": True, "value": None,},))
        boolControlsVmax = boolControls.child(dbc.Col, width=6).child(
            LabeledInput(
                label_text="Vmax", className="w-auto", size="sm",
                input_props={"type": "number", "debounce": True, "value": None,},))
        s2nControls = botImageControls.child(dbc.Col, width=4).child(dbc.Row)
        s2nControlsVmin = s2nControls.child(dbc.Col, width=6).child(
            LabeledInput(
                label_text="Vmin", className="w-auto", size="sm",
                input_props={"type": "number", "debounce": True, "value": None,},))
        s2nControlsVmax = s2nControls.child(dbc.Col, width=6).child(
            LabeledInput(
                label_text="Vmax", className="w-auto", size="sm",
                input_props={"type": "number", "debounce": True, "value": None,},))
        images = {'signal': {'control': {'vmin': signalControlsVmin, 'vmax': signalControlsVmax},},
                  'weight': {'control': {'vmin': weightControlsVmin, 'vmax': weightControlsVmax},},
                  'kernel': {'control': {'vmin': kernelControlsVmin, 'vmax': kernelControlsVmax},},
                  'cover': {'control': {'vmin': coverControlsVmin, 'vmax': coverControlsVmax},},
                  'bool': {'control': {'vmin': boolControlsVmin, 'vmax': boolControlsVmax},},
                  's2n': {'control': {'vmin': s2nControlsVmin, 'vmax': s2nControlsVmax},},
                  'plot': topImage,}

        # Another break
        bigBox.child(dbc.Row).child(html.Br)
        
        # Map Histogram
        imageOptions = [{'label': a, 'value': a} for a in ['signal', 'weight', 'sig2noise']]
        histBox = bigBox.child(dbc.Row)
        histPlotPanel = histBox.child(dbc.Row)
        histControlPanel = histBox.child(dbc.Row)
        histControl = histControlPanel.child(
            dcc.RadioItems,
            options=imageOptions,
            inline=True,
            value='signal',
        )
        histPlot = histPlotPanel.child(dcc.Graph)
        pixelHistogram = {'controls': histControl,
                          'plot': histPlot}

        self._registerCallbacks(app, fitsPath_select, images, pixelHistogram)
        return

    def _registerCallbacks(self, app, fitsPath_select, images, pixelHistogram):
        print("Registering Callbacks")

        # ---------------------------
        # FITS Path dropdown
        # ---------------------------
        @app.callback(
            [
                Output(pixelHistogram['plot'].id, "figure"),
                Output(images['plot'].id, "figure"),
            ],
            [
                Input(fitsPath_select.id, 'value'),
                Input(pixelHistogram['controls'].id, 'value'),
                Input(images['signal']['control']['vmin'].input.id, 'value'),
                Input(images['signal']['control']['vmax'].input.id, 'value'),
                Input(images['weight']['control']['vmin'].input.id, 'value'),
                Input(images['weight']['control']['vmax'].input.id, 'value'),
                Input(images['kernel']['control']['vmin'].input.id, 'value'),
                Input(images['kernel']['control']['vmax'].input.id, 'value'),
                Input(images['cover']['control']['vmin'].input.id, 'value'),
                Input(images['cover']['control']['vmax'].input.id, 'value'),
                Input(images['bool']['control']['vmin'].input.id, 'value'),
                Input(images['bool']['control']['vmax'].input.id, 'value'),
                Input(images['s2n']['control']['vmin'].input.id, 'value'),
                Input(images['s2n']['control']['vmax'].input.id, 'value'),
            ],
            prevent_initial_call=True
        )
        def primaryDropdown(path, histImage, svmin, svmax, wvmin, wvmax, kvmin, kvmax,
                            cvmin, cvmax, bvmin, bvmax, s2vmin, s2vmax):
            if((path == '') | (path is None)):
                raise PreventUpdate
            tsf = ToltecSignalFits(path=path)
            tsf.setWeightCut(0.2)
            histImage = histImage + '_I'
            histFig = tsf.plotMapHistogram(histImage, returnPlotlyPlot=True)
            ranges = [svmin, svmax, wvmin, wvmax, kvmin, kvmax, cvmin, cvmax,
                      bvmin, bvmax, s2vmin, s2vmax]
            imageFig = makeImages(tsf, ranges)
            return [histFig, imageFig]



def makeImages(tsf, ranges):
    fig = make_subplots(rows=2, cols=3, shared_xaxes='all', shared_yaxes='all',
                        horizontal_spacing=0.001, vertical_spacing=0.001,
                        subplot_titles=["Signal Map", "Weight Map", "Kernel Map",
                                        "Coverage Map", "Coverage Bool", "S/N Map"])
    for i, im in enumerate(['signal_I', 'weight_I', 'kernel_I']):
        image = tsf.getMap(im)
        vmin = ranges[2*i]
        vmax = ranges[2*i+1]
        if((image.shape[0]>1000) | (image.shape[1]>1000)):
            bs=True
        else:
            bs=False
        fig.add_trace(
            px.imshow(image, zmin=vmin, zmax=vmax, binary_string=bs).data[0],
            row=1, col=i+1)
    for i, im in enumerate(['coverage_I', 'coverage_bool_I', 'sig2noise_I']):
        image = tsf.getMap(im)
        vmin = ranges[6+2*i]
        vmax = ranges[6+2*i+1]
        if((image.shape[0]>1000) | (image.shape[1]>1000)):
            bs=True
        else:
            bs=False
        fig.add_trace(
            px.imshow(image, zmin=vmin, zmax=vmax, binary_string=bs).data[0],
            row=2, col=i+1)

    # Tidy things up with layout
    margin=go.layout.Margin(
        l=10, #left margin
        r=10, #right margin
        b=10, #bottom margin
        t=10, #top margin
    )
    fig.update_layout(margin=margin, height=900)
    return fig




DASHA_SITE = {
    "dasha": {
        "template": ToltecSignalFitsViewer,
        "THEME": dbc.themes.LUMEN,
        "DEBUG": os.environ.get("DASH_DEBUG", True),
    }
}
